-- readline: 
	#include <stdio.h>
	#include <readline/readline.h>
	#include <readline/history.h>

	char *readline (const char *prompt);

	Reads a line from the terminal with editing capabilities. Uses prompt param as prompt, if prompt is NULL or empty string, no prompt is issued. 
	Removes final newline.
	
	Return: Text of line read. Line returned is allocated. Caller frees.

	Brief manual: https://www.man7.org/linux/man-pages/man3/readline.3.html
	Extensive manual: https://tiswww.cwru.edu/php/chet/readline/readline.html

-- rl_clear_history:
	void rl_clear_history (void);
	
	Clears the history list by deleting all of the entries. It frees private data readline saves in the history list. 
	Similar behaviour as in clear_history().

-- rl_on_new_line:
	int rl_on_new_line (void);
	
	Tell the update functions that we have moved onto a new (empty) line, usually after outputting a newline. 

-- rl_replace_line:
	void rl_replace_line (const char *text, int clear_undo);
	
	Replace the contents of rl_line_buffer with text. The point and mark are preserved, if possible. 
	If clear_undo is non-zero, the undo list associated with the current line is cleared. 

-- rl_redisplay:
	void rl_redisplay (void);

	Change what's displayed on the screen to reflect the current contents of rl_line_buffer.

-- add_history:
	void add_history (const char *string);
	
	From readline manual: If you want the user to be able to get at the line later, you must call add_history() to save the line away in a history list of such lines.
	
	From history(3) manual: The history library is able to keep track of lines read. 
	Add_history() places the string at the end of the history list. Associated data field (if exists) is set to NULL.
	Max number of history entries is set with stifle_history(), if reached, oldest entry is removed.

	Manual History Library: https://www.man7.org/linux/man-pages/man3/history.3.html

/**
*@brief The  tputs  routine  applies  padding information to the
       string str
*
*@param str must be a terminfo string variable
           or  the return value from tparm, tiparm, tgetstr, or
           tgoto
*@param affcnt is the number of lines affected, or 1 if  not
           applicable.
*@param putc is a putchar-like routine to which the charac‐
           ters are passed, one at a time		   
*@return ERR upon failure, OK upon success
*/
int tputs(const char *str, int affcnt, int (*putc)(int))

/**
*@brief The tgoto routine expands the given capability using the
       parameters.

       •   Because  the capability may have padding characters,
           the output of tgoto should be passed to tputs rather
           than some other output function such as printf.

       •   While tgoto is assumed to be used for the two-param‐
           eter cursor positioning capability, termcap applica‐
           tions also use it for single-parameter capabilities.
		   Doing  this  shows  a  quirk in tgoto: most hardware
           terminals use cursor addressing with row first,  but
           the  original  developers  of  the termcap interface
           chose to put the column parameter first.  The  tgoto
           function  swaps  the  order  of parameters.  It does
           this also for calls requiring only a single  parame‐
           ter.   In that case, the first parameter is merely a
           placeholder.

		•  Normally the ncurses library is compiled  with  ter‐
           minfo  support.   In that case, tgoto uses tparm(3X)
           (a more capable formatter).

           However, tparm is not a termcap feature, and  porta‐
           ble  termcap  applications  should not rely upon its
           availability.
*/
char *tgoto(const char *cap, int col, int row);

/**
	The tgetstr routine returns the string entry for id, or zero if it is  not  avail‐
    able.   Use  tputs  to  output the returned string.  The area parameter is used as
    follows:

      •   It is assumed to be the address of a pointer to a  buffer  managed  by  the
          calling application.

      •   However,  ncurses checks to ensure that area is not NULL, and also that the
          resulting buffer pointer is not NULL.  If either check fails, the area  pa‐
          rameter is ignored.

      •   If  the  checks succeed, ncurses also copies the return value to the buffer
          pointed to by area, and the area value will be updated to  point  past  the
          null ending this value.

      •   The  return value itself is an address in the terminal description which is
          loaded into memory.

   Only the first two characters of the id parameter of tgetflag, tgetnum and tgetstr
   are compared in lookups.
*/
char *tgetstr(const char *id, char **area);

/**
*@brief The tgetnum routine gets the numeric entry for id, or -1 if it is not available.
*/
int tgetnum(const char *id);

/**
*@brief The  tgetflag routine gets the boolean entry for id, or zero if it is not
       available.
*/
int tgetflag(const char *id);

/**
*@brief The tgetent routine loads the entry for name.  It returns:

          1  on success,

          0  if there is no such entry (or that it is a generic type, having too
             little information for curses applications to run), and

          -1 if the terminfo database could not be found.
*/
int tgetent(char *bp, const char *name);

/**
*@brief tcgetattr() gets the parameters associated with the object referred by fd
       and  stores  them in the termios structure referenced by termios_p.  This
       function may be invoked from a background process; however, the  terminal
       attributes may be subsequently changed by a foreground process.
*/
int tcgetattr(int fd, struct termios *termios_p);

/**
*@brief tcsetattr() sets the parameters associated with the terminal (unless sup‐
       port is required from the underlying hardware that is not available) from
       the  termios structure referred to by termios_p.  optional_actions speci‐
       fies when the changes take effect:
       TCSANOW
              the change occurs immediately.

       TCSADRAIN
              the change occurs after all output written to fd has  been  trans‐
              mitted.   This option should be used when changing parameters that
              affect output.

       TCSAFLUSH
              the change occurs after all output written to the object  referred
              by  fd  has been transmitted, and all input that has been received
              but not read will be discarded before the change is made.
*/
int tcsetattr(int fd, int optional_actions,
                     const struct termios *termios_p);

/**
*@brief searches the environment list to find the environ‐
       ment variable name, and returns a  pointer  to  the  corresponding  value
       string.
*@return a pointer to the value in the  environment,
       or NULL if there is no match.
*/
char *getenv(const char *name);

/**
*@brief The  ioctl()  system call manipulates the underlying device parameters of
       special files.  In particular, many operating characteristics of  charac‐
       ter  special  files  (e.g., terminals) may be controlled with ioctl() re‐
       quests.  The argument fd must be an open file descriptor.

       The second argument is a device-dependent request code.  The third  argu‐
       ment  is  an  untyped  pointer  to memory.  It's traditionally char *argp
       (from the days before void * was valid C), and will be so named for  this
       discussion.

       An ioctl() request has encoded in it whether the argument is an in param‐
       eter or out parameter, and the  size  of  the  argument  argp  in  bytes.
       Macros  and  defines used in specifying an ioctl() request are located in
       the file <sys/ioctl.h>.
*@return Usually, on success zero is returned.  A few ioctl() requests use the re‐
       turn  value as an output parameter and return a nonnegative value on suc‐
       cess.  On error, -1 is returned, and errno is set appropriately.
*/
int ioctl(int fd, unsigned long request, ...);

/**
*@brief The legacy function ttyslot() returns the index of the current user's en‐
       try in some file.
*@return If successful, this function returns the slot number.  On error (e.g., if
       none of the file descriptors 0, 1 or 2 is associated with a terminal that
       occurs  in  this  data  base) it returns 0 on UNIX V6 and V7 and BSD-like
       systems, but -1 on System V-like systems.
*/
int ttyslot(void);

/**
*@brief The  function ttyname() returns a pointer to the null-terminated pathname
       of the terminal device that is open on the file descriptor fd, or NULL on
       error  (for  example,  if fd is not connected to a terminal).  The return
       value may point to static data, possibly overwritten by  the  next  call.
       The function ttyname_r() stores this pathname in the buffer buf of length
       buflen.
*@return The function ttyname() returns a pointer to a pathname  on  success.   On
       error,  NULL  is  returned, and errno is set appropriately.  The function
       ttyname_r() returns 0 on success, and an error number upon error.
*/
char *ttyname(int fd);

/**
*@brief The  isatty() function tests whether fd is an open file descriptor refer‐
       ring to a terminal.
*@return isatty() returns 1 if fd is an open file descriptor referring to a termi‐
       nal; otherwise 0 is returned, and errno is set to indicate the error.
*/
int isatty(int fd);

/**
*@brief The perror() function produces a message on standard error describing the
       last error encountered during a call to a system or library function.

       First (if s is not NULL and *s is not a null byte ('\0')),  the  argument
       string s is printed, followed by a colon and a blank.  Then an error mes‐
       sage corresponding to the current value of errno and a new-line.

       To be of most use, the argument string should include  the  name  of  the
       function that incurred the error.
       The  global  error list sys_errlist[], which can be indexed by errno, can
       be used to obtain the error message without  the  newline.   The  largest
       message  number provided in the table is sys_nerr-1.  Be careful when di‐
       rectly accessing this list, because new error values may  not  have  been
       added to sys_errlist[].  The use of sys_errlist[] is nowadays deprecated;
       use strerror(3) instead.

       When a system call fails, it usually returns -1 and sets the variable er‐
       rno to a value describing what went wrong.  (These values can be found in
       <errno.h>.)  Many library functions do likewise.  The  function  perror()
       serves  to translate this error code into human-readable form.  Note that
       errno is undefined after a successful system  call  or  library  function
       call:  this  call may well change this variable, even though it succeeds,
       for example because it internally used some other library  function  that
       failed.  Thus, if a failing call is not immediately followed by a call to
       perror(), the value of errno should be saved.
*/
void perror(const char *s);

/**
*@brief The  strerror()  function  returns a pointer to a string that describes the
       error code passed in the argument errnum, possibly  using  the  LC_MESSAGES
       part  of the current locale to select the appropriate language.  (For exam‐
       ple, if errnum is EINVAL, the returned description will be  "Invalid  argu‐
       ment".)   This  string  must not be modified by the application, but may be
       modified by a subsequent call to strerror() or strerror_l().  No other  li‐
       brary function, including perror(3), will modify this string.
*@return The  strerror(),  strerror_l(), and the GNU-specific strerror_r() functions
       return the appropriate error description string, or an "Unknown error  nnn"
       message if the error number is unknown.
*/
char *strerror(int errnum);

/**
*@brief The  closedir()  function closes the directory stream associated with dirp.
       A successful call to closedir() also closes the underlying file  descriptor
       associated  with  dirp.  The directory stream descriptor dirp is not avail‐
       able after this call.
*@return The closedir() function returns 0 on success.  On error,  -1  is  returned,
       and errno is set appropriately.
*/
 int closedir(DIR *dirp);

/**
*@brief The readdir() function returns a pointer to a dirent structure representing
       the next directory entry in the directory stream pointed to  by  dirp.   It
       returns NULL on reaching the end of the directory stream or if an error oc‐
       curred.
*@return On success, readdir() returns a  pointer  to  a  dirent  structure.   (This
       structure may be statically allocated; do not attempt to free(3) it.)

       If  the  end of the directory stream is reached, NULL is returned and errno
       is not changed.  If an error occurs, NULL is returned and errno is set  ap‐
       propriately.   To distinguish end of stream and from an error, set errno to
       zero before calling readdir() and then check the value of errno if NULL  is
       returned.
*/
struct dirent *readdir(DIR *dirp);

/**
*@brief The opendir() function opens a directory stream corresponding to the direc‐
       tory name, and returns a pointer to the directory stream.   The  stream  is
       positioned at the first entry in the directory.
*@return The opendir() and fdopendir() functions return a pointer to  the  directory
       stream.  On error, NULL is returned, and errno is set appropriately.
*/
DIR *opendir(const char *name);

/**
*@brief  pipe()  creates  a pipe, a unidirectional data channel that can be used for
       interprocess communication.  The array pipefd is used to  return  two  file
       descriptors  referring  to  the  ends of the pipe.  pipefd[0] refers to the
       read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data
       written  to the write end of the pipe is buffered by the kernel until it is
       read from the read end of the pipe.  For further details, see pipe(7).
*@return  On success, zero is returned.  On error, -1 is returned, errno is  set  ap‐
       propriately, and pipefd is left unchanged.

       On  Linux (and other systems), pipe() does not modify pipefd on failure.  A
       requirement standardizing this behavior was  added  in  POSIX.1-2016.   The
       Linux-specific pipe2() system call likewise does not modify pipefd on fail‐
       ure.
*/
int pipe(int pipefd[2]);

/**
*@brief The  dup()  system  call creates a copy of the file descriptor oldfd, using
       the lowest-numbered unused file descriptor for the new descriptor.

       After a successful return, the old and new file descriptors may be used in‐
       terchangeably.   They refer to the same open file description (see open(2))
       and thus share file offset and file status flags; for example, if the  file
       offset  is  modified  by using lseek(2) on one of the file descriptors, the
       offset is also changed for the other.

       The two file descriptors do not share file descriptor flags (the  close-on-
       exec  flag).  The close-on-exec flag (FD_CLOEXEC; see fcntl(2)) for the du‐
       plicate descriptor is off.
*@return On  success,  these system calls return the new file descriptor.  On error,
       -1 is returned, and errno is set appropriately.
*/
int dup(int oldfd);

/**
*@brief The dup2() system call performs the same task as dup(), but instead of  us‐
       ing the lowest-numbered unused file descriptor, it uses the file descriptor
       number specified in newfd.  If the file  descriptor  newfd  was  previously
       open, it is silently closed before being reused.

       The  steps  of  closing and reusing the file descriptor newfd are performed
       atomically.  This is important,  because  trying  to  implement  equivalent
       functionality using close(2) and dup() would be subject to race conditions,
       whereby newfd might be reused between the two steps.  Such reuse could hap‐
       pen  because the main program is interrupted by a signal handler that allo‐
       cates a file descriptor, or because a parallel thread allocates a file  de‐
       scriptor.
*@return On  success,  these system calls return the new file descriptor.  On error,
       -1 is returned, and errno is set appropriately.
*/
int dup2(int oldfd, int newfd);

/**
*@brief execve()  executes  the  program  referred to by pathname.  This causes the
       program that is currently being run by the calling process to  be  replaced
       with  a  new  program, with newly initialized stack, heap, and (initialized
       and uninitialized) data segments.
*@return On success, execve() does not return, on error -1 is returned, and errno is
       set appropriately.
*/
int execve(const char *pathname, char *const argv[],
                  char *const envp[]);

/**
*@brief unlink()  deletes  a  name  from the filesystem.  If that name was the last
       link to a file and no processes have the file open, the file is deleted and
       the space it was using is made available for reuse.

       If  the  name  was the last link to a file but any processes still have the
       file open, the file will remain in existence until the last file descriptor
       referring to it is closed.

       If the name referred to a symbolic link, the link is removed.

       If  the  name referred to a socket, FIFO, or device, the name for it is re‐
       moved but processes which have the object open may continue to use it.
*@return On  success,  zero is returned.  On error, -1 is returned, and errno is set
       appropriately.
*/
int unlink(const char *pathname);

/**
*@brief These  functions  return information about a file, in the buffer pointed to
       by statbuf.  No permissions are required on the  file  itself,  but—in  the
       case  of  stat(), fstatat(), and lstat()—execute (search) permission is re‐
       quired on all of the directories in pathname that lead to the file.

       stat() and fstatat() retrieve information about  the  file  pointed  to  by
       pathname; the differences for fstatat() are described below.
*@return On success, zero is returned.  On error, -1 is returned, and errno  is  set
       appropriately.
*/
int stat(const char *pathname, struct stat *statbuf);

/**
*@brief These  functions  return information about a file, in the buffer pointed to
       by statbuf.  No permissions are required on the  file  itself,  but—in  the
       case  of  stat(), fstatat(), and lstat()—execute (search) permission is re‐
       quired on all of the directories in pathname that lead to the file.

       stat() and fstatat() retrieve information about  the  file  pointed  to  by
       pathname; the differences for fstatat() are described below.

       fstat()  is  identical to stat(), except that the file about which informa‐
       tion is to be retrieved is specified by the file descriptor fd.
*@return On success, zero is returned.  On error, -1 is returned, and errno  is  set
       appropriately.
*/
int fstat(int fd, struct stat *statbuf);


/**
*@brief chdir() changes the current working directory of the calling process to the
       directory specified in path.
*@return On  success,  zero is returned.  On error, -1 is returned, and errno is set
       appropriately.
*/
int chdir(const char *path);

/**
*@brief These  functions  return  a  null-terminated  string containing an absolute
       pathname that is the current working directory of the calling process.  The
       pathname  is  returned  as the function result and via the argument buf, if
       present.

       The getcwd() function copies an absolute pathname of  the  current  working
       directory to the array pointed to by buf, which is of length size.

       If  the  length  of the absolute pathname of the current working directory,
       including the terminating null byte, exceeds size bytes, NULL is  returned,
       and errno is set to ERANGE; an application should check for this error, and
       allocate a larger buffer if necessary.

       As an extension to the POSIX.1-2001 standard,  glibc's  getcwd()  allocates
       the  buffer  dynamically using malloc(3) if buf is NULL.  In this case, the
       allocated buffer has the length size unless size is zero, when buf is allo‐
       cated as big as necessary.  The caller should free(3) the returned buffer.
*@return On  success,  these  functions  return a pointer to a string containing the
       pathname of the current working directory.  In the  case  of  getcwd()  and
       getwd() this is the same value as buf.

       On  failure,  these functions return NULL, and errno is set to indicate the
       error.  The contents of the array pointed to by buf are undefined on error.
*/
char *getcwd(char *buf, size_t size);

/**
*@brief The exit() function causes normal process termination and the value of sta‐
       tus & 0xFF is returned to the parent (see wait(2)).

       The C standard specifies two constants, EXIT_SUCCESS and EXIT_FAILURE, that
       may be passed to exit() to indicate successful or unsuccessful termination,
       respectively.
*@return The exit() function does not return.
*/
void exit(int status);

/**
*@brief The  kill() system call can be used to send any signal to any process group
       or process.

       If pid is positive, then signal sig is sent to  the  process  with  the  ID
       specified by pid.

       If  pid equals 0, then sig is sent to every process in the process group of
       the calling process.

       If pid equals -1, then sig is sent to every process for which  the  calling
       process  has  permission  to send signals, except for process 1 (init), but
       see below.

       If pid is less than -1, then sig is sent to every process  in  the  process
       group whose ID is -pid.
       If  sig  is  0, then no signal is sent, but existence and permission checks
       are still performed; this can be used to  check  for  the  existence  of  a
       process ID or process group ID that the caller is permitted to signal.

       For a process to have permission to send a signal, it must either be privi‐
       leged (under Linux: have the CAP_KILL capability in the user  namespace  of
       the  target  process),  or  the  real  or  effective user ID of the sending
       process must equal the real or saved set-user-ID of the target process.  In
       the  case  of SIGCONT, it suffices when the sending and receiving processes
       belong to the same session.  (Historically, the rules were  different;  see
       NOTES.)
*@return On  success (at least one signal was sent), zero is returned.  On error, -1
       is returned, and errno is set appropriately.
*/
int kill(pid_t pid, int sig);

/**
*@brief These functions allow the manipulation of POSIX signal sets.

       sigaddset()  and sigdelset() add and delete respectively signal signum from
       set.
*@return sigemptyset(), sigfillset(), sigaddset(), and sigdelset() return 0 on  suc‐
       cess and -1 on error.
*/
int sigaddset(sigset_t *set, int signum);

/**
*@brief These functions allow the manipulation of POSIX signal sets.

       sigemptyset() initializes the signal set given by set to  empty,  with  all
       signals excluded from the set.
*@return sigemptyset(), sigfillset(), sigaddset(), and sigdelset() return 0 on  suc‐
       cess and -1 on error.
*/
int sigemptyset(sigset_t *set);

/**
*@brief The sigaction() system call is used to change the action taken by a process
       on receipt of a specific signal.  (See signal(7) for an  overview  of  sig‐
       nals.)
*@return sigaction() returns 0 on success; on error, -1 is returned,  and  errno  is
       set to indicate the error.
*/
int sigaction(int signum, const struct sigaction *act,
                     struct sigaction *oldact);

/**
*@brief The  behavior  of signal() varies across UNIX versions, and has also varied
       historically across different versions of Linux.  Avoid its use: use sigac‐
       tion(2) instead.  See Portability below.

       signal() sets the disposition of the signal signum to handler, which is ei‐
       ther SIG_IGN, SIG_DFL, or the address of a programmer-defined  function  (a
       "signal handler").
*@return signal()  returns  the  previous value of the signal handler, or SIG_ERR on
       error.  In the event of an error, errno is set to indicate the cause.
*/
sighandler_t signal(int signum, sighandler_t handler);

/**
*@brief These  functions are nonstandard; in new programs, the use of waitpid(2) or
       waitid(2) is preferable.

       The wait3() and wait4() system calls are similar to waitpid(2),  but  addi‐
       tionally return resource usage information about the child in the structure
       pointed to by rusage.

       Other than the use of the rusage argument, the following wait3() call:

           wait3(wstatus, options, rusage);

       is equivalent to:

           waitpid(-1, wstatus, options);

       Similarly, the following wait4() call:
       wait4(pid, wstatus, options, rusage);

       is equivalent to:

           waitpid(pid, wstatus, options);
    In other words, wait3() waits of any child, while wait4() can  be  used  to
       select  a  specific  child, or children, on which to wait.  See wait(2) for
       further details.

       If rusage is not NULL, the struct rusage to which it points will be  filled
       with accounting information about the child.  See getrusage(2) for details.
*@return As for waitpid(2).
*/
pid_t wait3(int *wstatus, int options,
                   struct rusage *rusage);

/**
*@brief These  functions are nonstandard; in new programs, the use of waitpid(2) or
       waitid(2) is preferable.

       The wait3() and wait4() system calls are similar to waitpid(2),  but  addi‐
       tionally return resource usage information about the child in the structure
       pointed to by rusage.

       Other than the use of the rusage argument, the following wait3() call:

           wait3(wstatus, options, rusage);

       is equivalent to:

           waitpid(-1, wstatus, options);

       Similarly, the following wait4() call:
       wait4(pid, wstatus, options, rusage);

       is equivalent to:

           waitpid(pid, wstatus, options);
    In other words, wait3() waits of any child, while wait4() can  be  used  to
       select  a  specific  child, or children, on which to wait.  See wait(2) for
       further details.

       If rusage is not NULL, the struct rusage to which it points will be  filled
       with accounting information about the child.  See getrusage(2) for details.
*@return As for waitpid(2).
*/
pid_t wait4(pid_t pid, int *wstatus, int options,
                   struct rusage *rusage);

/**
*@brief All  of these system calls are used to wait for state changes in a child of
       the calling process, and obtain information about the child whose state has
       changed.   A  state  change  is considered to be: the child terminated; the
       child was stopped by a signal; or the child was resumed by  a  signal.   In
       the  case of a terminated child, performing a wait allows the system to re‐
       lease the resources associated with the child; if a wait is not  performed,
       then the terminated child remains in a "zombie" state (see NOTES below).

       If  a child has already changed state, then these calls return immediately.
       Otherwise, they block until either a child changes state or a  signal  han‐
       dler  interrupts the call (assuming that system calls are not automatically
       restarted using the SA_RESTART flag of sigaction(2)).  In the remainder  of
       this  page,  a  child  whose  state  has changed and which has not yet been
       waited upon by one of these system calls is termed waitable.

       The wait() system call suspends execution of the calling thread  until  one
       of its children terminates.  The call wait(&wstatus) is equivalent to:

           waitpid(-1, &wstatus, 0);
*@return wait(): on success, returns the process ID of the terminated child; on  er‐
       ror, -1 is returned.
*/
pid_t wait(int *wstatus);

/**
*@brief All  of these system calls are used to wait for state changes in a child of
       the calling process, and obtain information about the child whose state has
       changed.   A  state  change  is considered to be: the child terminated; the
       child was stopped by a signal; or the child was resumed by  a  signal.   In
       the  case of a terminated child, performing a wait allows the system to re‐
       lease the resources associated with the child; if a wait is not  performed,
       then the terminated child remains in a "zombie" state (see NOTES below).

       If  a child has already changed state, then these calls return immediately.
       Otherwise, they block until either a child changes state or a  signal  han‐
       dler  interrupts the call (assuming that system calls are not automatically
       restarted using the SA_RESTART flag of sigaction(2)).  In the remainder  of
       this  page,  a  child  whose  state  has changed and which has not yet been
       waited upon by one of these system calls is termed waitable.

       The  waitpid() system call suspends execution of the calling thread until a
       child specified by pid argument has changed state.  By  default,  waitpid()
       waits only for terminated children, but this behavior is modifiable via the
       options argument, as described below.
*@return waitpid():  on success, returns the process ID of the child whose state has
       changed; if WNOHANG was specified and one or more child(ren)  specified  by
       pid  exist,  but have not yet changed state, then 0 is returned.  On error,
       -1 is returned.
*/
pid_t waitpid(pid_t pid, int *wstatus, int options);

/**
*@brief fork()  creates  a new process by duplicating the calling process.  The new
       process is referred to as the child process.  The calling  process  is  re‐
       ferred to as the parent process.

       The child process and the parent process run in separate memory spaces.  At
       the time of fork() both  memory  spaces  have  the  same  content.   Memory
       writes,  file  mappings  (mmap(2)), and unmappings (munmap(2)) performed by
       one of the processes do not affect the other.
*@return On  success,  the PID of the child process is returned in the parent, and 0
       is returned in the child.  On failure, -1 is returned  in  the  parent,  no
       child process is created, and errno is set appropriately.
*/
pid_t fork(void);

/**
*@brief access()  checks  whether the calling process can access the file pathname.
       If pathname is a symbolic link, it is dereferenced.
*@return On success (all requested permissions granted, or mode is F_OK and the file
       exists), zero is returned.  On error (at least one bit in mode asked for  a
       permission  that is denied, or mode is F_OK and the file does not exist, or
       some other error occurred), -1 is returned, and errno is set appropriately.
*/
int access(const char *pathname, int mode);

/**
*@brief Place string at the end of the history list.  The associated data
       field (if any) is set to NULL.  If the maximum number of history
       entries has been set using stifle_history(), and the new number
       of history entries would exceed that maximum, the oldest history
       entry is removed.
*/
void add_history (const char *string)

