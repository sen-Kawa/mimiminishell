-- readline: 
	#include <stdio.h>
	#include <readline/readline.h>
	#include <readline/history.h>

	char *readline (const char *prompt);

	Reads a line from the terminal with editing capabilities. Uses prompt param as prompt, if prompt is NULL or empty string, no prompt is issued. Removes final newline.
	Return: Text of line read. Line returned is allocated. Caller frees.

	Brief manual: https://www.man7.org/linux/man-pages/man3/readline.3.html
	Extensive manual: https://tiswww.cwru.edu/php/chet/readline/readline.html

-- rl_clear_history:
	void rl_clear_history (void);
	
	Clears the history list by deleting all of the entries. It frees private data readline saves in the history list. Similar behaviour as in clear_history().

-- rl_on_new_line:
	int rl_on_new_line (void);
	
	Tell the update functions that we have moved onto a new (empty) line, usually after outputting a newline. 

-- rl_replace_line:
	void rl_replace_line (const char *text, int clear_undo);
	
	Replace the contents of rl_line_buffer with text. The point and mark are preserved, if possible. If clear_undo is non-zero, the undo list associated with the current line is cleared. 

-- rl_redisplay:
	void rl_redisplay (void);

	Change what's displayed on the screen to reflect the current contents of rl_line_buffer.

/**
*@brief The  tputs  routine  applies  padding information to the
       string str
*
*@param str must be a terminfo string variable
           or  the return value from tparm, tiparm, tgetstr, or
           tgoto
*@param affcnt is the number of lines affected, or 1 if  not
           applicable.
*@param putc is a putchar-like routine to which the charac‐
           ters are passed, one at a time		   
*@return ERR upon failure, OK upon success
*/
int tputs(const char *str, int affcnt, int (*putc)(int));

/**
*@brief The tgoto routine expands the given capability using the
       parameters.

       •   Because  the capability may have padding characters,
           the output of tgoto should be passed to tputs rather
           than some other output function such as printf.

       •   While tgoto is assumed to be used for the two-param‐
           eter cursor positioning capability, termcap applica‐
           tions also use it for single-parameter capabilities.
		   Doing  this  shows  a  quirk in tgoto: most hardware
           terminals use cursor addressing with row first,  but
           the  original  developers  of  the termcap interface
           chose to put the column parameter first.  The  tgoto
           function  swaps  the  order  of parameters.  It does
           this also for calls requiring only a single  parame‐
           ter.   In that case, the first parameter is merely a
           placeholder.

		•  Normally the ncurses library is compiled  with  ter‐
           minfo  support.   In that case, tgoto uses tparm(3X)
           (a more capable formatter).

           However, tparm is not a termcap feature, and  porta‐
           ble  termcap  applications  should not rely upon its
           availability.
*/
char *tgoto(const char *cap, int col, int row);

/**
	The tgetstr routine returns the string entry for id, or zero if it is  not  avail‐
    able.   Use  tputs  to  output the returned string.  The area parameter is used as
    follows:

      •   It is assumed to be the address of a pointer to a  buffer  managed  by  the
          calling application.

      •   However,  ncurses checks to ensure that area is not NULL, and also that the
          resulting buffer pointer is not NULL.  If either check fails, the area  pa‐
          rameter is ignored.

      •   If  the  checks succeed, ncurses also copies the return value to the buffer
          pointed to by area, and the area value will be updated to  point  past  the
          null ending this value.

      •   The  return value itself is an address in the terminal description which is
          loaded into memory.

   Only the first two characters of the id parameter of tgetflag, tgetnum and tgetstr
   are compared in lookups.
*/
char *tgetstr(const char *id, char **area);

/**
*@brief The tgetnum routine gets the numeric entry for id, or -1 if it is not available.
*/
int tgetnum(const char *id);

/**
*@brief The  tgetflag routine gets the boolean entry for id, or zero if it is not
       available.
*/
int tgetflag(const char *id);

/**
*@brief The tgetent routine loads the entry for name.  It returns:

          1  on success,

          0  if there is no such entry (or that it is a generic type, having too
             little information for curses applications to run), and

          -1 if the terminfo database could not be found.
*/
int tgetent(char *bp, const char *name);

/**
*@brief tcgetattr() gets the parameters associated with the object referred by fd
       and  stores  them in the termios structure referenced by termios_p.  This
       function may be invoked from a background process; however, the  terminal
       attributes may be subsequently changed by a foreground process.
*/
int tcgetattr(int fd, struct termios *termios_p);

/**
*@brief tcsetattr() sets the parameters associated with the terminal (unless sup‐
       port is required from the underlying hardware that is not available) from
       the  termios structure referred to by termios_p.  optional_actions speci‐
       fies when the changes take effect:
       TCSANOW
              the change occurs immediately.

       TCSADRAIN
              the change occurs after all output written to fd has  been  trans‐
              mitted.   This option should be used when changing parameters that
              affect output.

       TCSAFLUSH
              the change occurs after all output written to the object  referred
              by  fd  has been transmitted, and all input that has been received
              but not read will be discarded before the change is made.
*/
int tcsetattr(int fd, int optional_actions,
                     const struct termios *termios_p);

/**
*@brief searches the environment list to find the environ‐
       ment variable name, and returns a  pointer  to  the  corresponding  value
       string.
*@return a pointer to the value in the  environment,
       or NULL if there is no match.
*/
char *getenv(const char *name);

/**
*@brief The  ioctl()  system call manipulates the underlying device parameters of
       special files.  In particular, many operating characteristics of  charac‐
       ter  special  files  (e.g., terminals) may be controlled with ioctl() re‐
       quests.  The argument fd must be an open file descriptor.

       The second argument is a device-dependent request code.  The third  argu‐
       ment  is  an  untyped  pointer  to memory.  It's traditionally char *argp
       (from the days before void * was valid C), and will be so named for  this
       discussion.

       An ioctl() request has encoded in it whether the argument is an in param‐
       eter or out parameter, and the  size  of  the  argument  argp  in  bytes.
       Macros  and  defines used in specifying an ioctl() request are located in
       the file <sys/ioctl.h>.
*@return Usually, on success zero is returned.  A few ioctl() requests use the re‐
       turn  value as an output parameter and return a nonnegative value on suc‐
       cess.  On error, -1 is returned, and errno is set appropriately.
*/
int ioctl(int fd, unsigned long request, ...);

/**
*@brief The legacy function ttyslot() returns the index of the current user's en‐
       try in some file.
*@return If successful, this function returns the slot number.  On error (e.g., if
       none of the file descriptors 0, 1 or 2 is associated with a terminal that
       occurs  in  this  data  base) it returns 0 on UNIX V6 and V7 and BSD-like
       systems, but -1 on System V-like systems.
*/
int ttyslot(void);

/**
*@brief The  function ttyname() returns a pointer to the null-terminated pathname
       of the terminal device that is open on the file descriptor fd, or NULL on
       error  (for  example,  if fd is not connected to a terminal).  The return
       value may point to static data, possibly overwritten by  the  next  call.
       The function ttyname_r() stores this pathname in the buffer buf of length
       buflen.
*@return The function ttyname() returns a pointer to a pathname  on  success.   On
       error,  NULL  is  returned, and errno is set appropriately.  The function
       ttyname_r() returns 0 on success, and an error number upon error.
*/
char *ttyname(int fd);

/**
*@brief The  isatty() function tests whether fd is an open file descriptor refer‐
       ring to a terminal.
*@return isatty() returns 1 if fd is an open file descriptor referring to a termi‐
       nal; otherwise 0 is returned, and errno is set to indicate the error.
*/
int isatty(int fd);

/**
*@brief The perror() function produces a message on standard error describing the
       last error encountered during a call to a system or library function.

       First (if s is not NULL and *s is not a null byte ('\0')),  the  argument
       string s is printed, followed by a colon and a blank.  Then an error mes‐
       sage corresponding to the current value of errno and a new-line.

       To be of most use, the argument string should include  the  name  of  the
       function that incurred the error.
       The  global  error list sys_errlist[], which can be indexed by errno, can
       be used to obtain the error message without  the  newline.   The  largest
       message  number provided in the table is sys_nerr-1.  Be careful when di‐
       rectly accessing this list, because new error values may  not  have  been
       added to sys_errlist[].  The use of sys_errlist[] is nowadays deprecated;
       use strerror(3) instead.

       When a system call fails, it usually returns -1 and sets the variable er‐
       rno to a value describing what went wrong.  (These values can be found in
       <errno.h>.)  Many library functions do likewise.  The  function  perror()
       serves  to translate this error code into human-readable form.  Note that
       errno is undefined after a successful system  call  or  library  function
       call:  this  call may well change this variable, even though it succeeds,
       for example because it internally used some other library  function  that
       failed.  Thus, if a failing call is not immediately followed by a call to
       perror(), the value of errno should be saved.
*/
void perror(const char *s);

/**
*@brief The  strerror()  function  returns a pointer to a string that describes the
       error code passed in the argument errnum, possibly  using  the  LC_MESSAGES
       part  of the current locale to select the appropriate language.  (For exam‐
       ple, if errnum is EINVAL, the returned description will be  "Invalid  argu‐
       ment".)   This  string  must not be modified by the application, but may be
       modified by a subsequent call to strerror() or strerror_l().  No other  li‐
       brary function, including perror(3), will modify this string.
*@return The  strerror(),  strerror_l(), and the GNU-specific strerror_r() functions
       return the appropriate error description string, or an "Unknown error  nnn"
       message if the error number is unknown.
*/
char *strerror(int errnum);

/**
*@brief The  closedir()  function closes the directory stream associated with dirp.
       A successful call to closedir() also closes the underlying file  descriptor
       associated  with  dirp.  The directory stream descriptor dirp is not avail‐
       able after this call.
*@return The closedir() function returns 0 on success.  On error,  -1  is  returned,
       and errno is set appropriately.
*/
 int closedir(DIR *dirp);

/**
*@brief The readdir() function returns a pointer to a dirent structure representing
       the next directory entry in the directory stream pointed to  by  dirp.   It
       returns NULL on reaching the end of the directory stream or if an error oc‐
       curred.
*@return On success, readdir() returns a  pointer  to  a  dirent  structure.   (This
       structure may be statically allocated; do not attempt to free(3) it.)

       If  the  end of the directory stream is reached, NULL is returned and errno
       is not changed.  If an error occurs, NULL is returned and errno is set  ap‐
       propriately.   To distinguish end of stream and from an error, set errno to
       zero before calling readdir() and then check the value of errno if NULL  is
       returned.
*/
struct dirent *readdir(DIR *dirp);

/**
*@brief The opendir() function opens a directory stream corresponding to the direc‐
       tory name, and returns a pointer to the directory stream.   The  stream  is
       positioned at the first entry in the directory.
*@return The opendir() and fdopendir() functions return a pointer to  the  directory
       stream.  On error, NULL is returned, and errno is set appropriately.
*/
DIR *opendir(const char *name);

/**
*@brief  pipe()  creates  a pipe, a unidirectional data channel that can be used for
       interprocess communication.  The array pipefd is used to  return  two  file
       descriptors  referring  to  the  ends of the pipe.  pipefd[0] refers to the
       read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data
       written  to the write end of the pipe is buffered by the kernel until it is
       read from the read end of the pipe.  For further details, see pipe(7).
*@return  On success, zero is returned.  On error, -1 is returned, errno is  set  ap‐
       propriately, and pipefd is left unchanged.

       On  Linux (and other systems), pipe() does not modify pipefd on failure.  A
       requirement standardizing this behavior was  added  in  POSIX.1-2016.   The
       Linux-specific pipe2() system call likewise does not modify pipefd on fail‐
       ure.
*/
int pipe(int pipefd[2]);

/**
*@brief The  dup()  system  call creates a copy of the file descriptor oldfd, using
       the lowest-numbered unused file descriptor for the new descriptor.

       After a successful return, the old and new file descriptors may be used in‐
       terchangeably.   They refer to the same open file description (see open(2))
       and thus share file offset and file status flags; for example, if the  file
       offset  is  modified  by using lseek(2) on one of the file descriptors, the
       offset is also changed for the other.

       The two file descriptors do not share file descriptor flags (the  close-on-
       exec  flag).  The close-on-exec flag (FD_CLOEXEC; see fcntl(2)) for the du‐
       plicate descriptor is off.
*@return On  success,  these system calls return the new file descriptor.  On error,
       -1 is returned, and errno is set appropriately.
*/
int dup(int oldfd);

/**
*@brief The dup2() system call performs the same task as dup(), but instead of  us‐
       ing the lowest-numbered unused file descriptor, it uses the file descriptor
       number specified in newfd.  If the file  descriptor  newfd  was  previously
       open, it is silently closed before being reused.

       The  steps  of  closing and reusing the file descriptor newfd are performed
       atomically.  This is important,  because  trying  to  implement  equivalent
       functionality using close(2) and dup() would be subject to race conditions,
       whereby newfd might be reused between the two steps.  Such reuse could hap‐
       pen  because the main program is interrupted by a signal handler that allo‐
       cates a file descriptor, or because a parallel thread allocates a file  de‐
       scriptor.
*@return On  success,  these system calls return the new file descriptor.  On error,
       -1 is returned, and errno is set appropriately.
*/
int dup2(int oldfd, int newfd);

/**
*@brief execve()  executes  the  program  referred to by pathname.  This causes the
       program that is currently being run by the calling process to  be  replaced
       with  a  new  program, with newly initialized stack, heap, and (initialized
       and uninitialized) data segments.
*@return On success, execve() does not return, on error -1 is returned, and errno is
       set appropriately.
*/
int execve(const char *pathname, char *const argv[],
                  char *const envp[]);

/**
*@brief unlink()  deletes  a  name  from the filesystem.  If that name was the last
       link to a file and no processes have the file open, the file is deleted and
       the space it was using is made available for reuse.

       If  the  name  was the last link to a file but any processes still have the
       file open, the file will remain in existence until the last file descriptor
       referring to it is closed.

       If the name referred to a symbolic link, the link is removed.

       If  the  name referred to a socket, FIFO, or device, the name for it is re‐
       moved but processes which have the object open may continue to use it.
*@return On  success,  zero is returned.  On error, -1 is returned, and errno is set
       appropriately.
*/
int unlink(const char *pathname);

/**
*@brief These  functions  return information about a file, in the buffer pointed to
       by statbuf.  No permissions are required on the  file  itself,  but—in  the
       case  of  stat(), fstatat(), and lstat()—execute (search) permission is re‐
       quired on all of the directories in pathname that lead to the file.

       stat() and fstatat() retrieve information about  the  file  pointed  to  by
       pathname; the differences for fstatat() are described below.
*@return On success, zero is returned.  On error, -1 is returned, and errno  is  set
       appropriately.
*/
int stat(const char *pathname, struct stat *statbuf);

/**
*@brief These  functions  return information about a file, in the buffer pointed to
       by statbuf.  No permissions are required on the  file  itself,  but—in  the
       case  of  stat(), fstatat(), and lstat()—execute (search) permission is re‐
       quired on all of the directories in pathname that lead to the file.

       stat() and fstatat() retrieve information about  the  file  pointed  to  by
       pathname; the differences for fstatat() are described below.

       fstat()  is  identical to stat(), except that the file about which informa‐
       tion is to be retrieved is specified by the file descriptor fd.
*@return On success, zero is returned.  On error, -1 is returned, and errno  is  set
       appropriately.
*/
int fstat(int fd, struct stat *statbuf);